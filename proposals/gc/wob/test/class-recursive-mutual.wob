// Simple mutual recursive classes
/*
class Even(n : Int) {
  func test() : Bool {
    if (n == 0) { return true };
    return (new Odd(n - 1)).test();
  };
};

class Odd(n : Int) {
  func test() : Bool {
    if (n == 0) { return false };
    return (new Even(n - 1)).test();
  };
};

assert (new Even(4)).test();
assert (new Odd(7)).test();

class Stepper() {
  func step() : Stepper { return null : Stepper };
};

class Ping(n : Int) <: Stepper() {
  func step() : Stepper {
    if (n == 0) { return null : Stepper };
    return new Pong(n - 1);
  };
};

class Pong(n : Int) <: Stepper() {
  func step() : Stepper {
    if (n == 0) { return null : Stepper };
    return new Ping(n - 1);
  };
};

var n : Int = 7;
var stepper : Stepper = new Ping(n);
while (stepper != null) {
  stepper := stepper.step();
  n := n-1;
};
assert (n == -1);
*/

// Expression evaluator and derivatives

class Exp() {
  func accept<A, R>(v : Visitor<A, R>, a : A) : R { accept<A, R>(v, a) };
};

class Lit(i : Int) <: Exp() {
  func accept<A, R>(v : Visitor<A, R>, a : A) : R {
    v.visitLit(this, a);
  };
  func value() : Int { i };
};

class Var(x : Text) <: Exp() {
  func accept<A, R>(v : Visitor<A, R>, a : A) : R {
    v.visitVar(this, a);
  };
  func name() : Text { x };
};

class Bin(e1 : Exp, e2 : Exp) <: Exp() {
  func left() : Exp { e1 };
  func right() : Exp { e2 };
};

class Add(e1 : Exp, e2 : Exp) <: Bin(e1, e2) {
  func accept<A, R>(v : Visitor<A, R>, a : A) : R {
    v.visitAdd(this, a);
  };
};

class Mul(e1 : Exp, e2 : Exp) <: Bin(e1, e2) {
  func accept<A, R>(v : Visitor<A, R>, a : A) : R {
    v.visitMul(this, a);
  };
};

class Visitor<A, R>() {
  func visit(exp : Exp, a : A) : R {
    exp.accept<A, R>(this, a);
  };
  func visitLit(exp : Lit, a : A) : R { visitLit(exp, a) };
  func visitVar(exp : Var, a : A) : R { visitVar(exp, a) };
  func visitAdd(exp : Add, a : A) : R { visitAdd(exp, a) };
  func visitMul(exp : Mul, a : A) : R { visitMul(exp, a) };
};


class Env<T>() {
  func lookup(x : Text) : T { null };
};

class Entry<T>(y : Text, v : T, parent : Env<T>) <: Env<T>() {
  func lookup(x : Text) : T { if (x == y) { v } else { parent.lookup(x) } };
};

class Evaluator() <: Visitor<Env<Int$>, Int$>() {
  func visitLit(exp : Lit, env : Env<Int$>) : Int$ {
    exp.value()$;
  };
  func visitVar(exp : Var, env : Env<Int$>) : Int$ {
    env.lookup(exp.name());
  };
  func visitAdd(exp : Add, env : Env<Int$>) : Int$ {
    let i1 = exp.left().accept<Env<Int$>, Int$>(this, env).$;
    let i2 = exp.right().accept<Env<Int$>, Int$>(this, env).$;
    (i1 + i2)$;
  };
  func visitMul(exp : Mul, env : Env<Int$>) : Int$ {
    let i1 = exp.left().accept<Env<Int$>, Int$>(this, env).$;
    let i2 = exp.right().accept<Env<Int$>, Int$>(this, env).$;
    (i1 * i2)$;
  };
};

let exp = new Mul(new Add(new Var("x"), new Lit(3)), new Lit(5));
let env1 = new Entry<Int$>("x", 0$, new Env<Int$>());
let env2 = new Entry<Int$>("y", 1$, new Entry<Int$>("x", 2$, new Env<Int$>()));
let eval = new Evaluator();
assert eval.visit(exp, env1).$ == 15;
assert eval.visit(exp, env2).$ == 25;


class Derive(x : Text) <: Visitor<(), Exp>() {
  func visitLit(exp : Lit, _ : ()) : Exp {
    new Lit(0);
  };
  func visitVar(exp : Var, _ : ()) : Exp {
    new Lit(if (x == exp.name()) { 1 } else { 0 });
  };
  func visitAdd(exp : Add, _ : ()) : Exp {
    let e1 = exp.left().accept<(), Exp>(this, ());
    let e2 = exp.right().accept<(), Exp>(this, ());
    new Add(e1, e2);
  };
  func visitMul(exp : Mul, _ : ()) : Exp {
    let e1 = exp.left().accept<(), Exp>(this, ());
    let e2 = exp.right().accept<(), Exp>(this, ());
    new Add(new Mul(e1, exp.right()), new Mul(exp.left(), e2));
  };
};

let derive = new Derive("x");
let expD = derive.visit(exp, ());
assert eval.visit(expD, env2).$ == 5;
